\chapter{Auswertung}
Wie bereits in Abschnitt \ref{cha:2-Vergleich} beschrieben wurde, sollen drei Compiler QHScompiler, THScompiler und GCC sowie deren dazugehörigen Sprachen QHS, THS und C verglichen werden.
Diese werden in Geschwindigkeit der Kompilierung, Geschwindigkeit eines kompilierten Programmes, Benutzerfreundlichkeit und Offenheit für Erweiterung bewertet. 

\section{Geschwindigkeit der Kompilierung} \label{sec:compare-compilespeed}
Für die Messung der Kompilierungsdauer wird eine Funktion, die prüft, ob eine Zahl eine Primzahl ist, kompiliert. Diese Funktion wurde so geschrieben, dass jedes Feature, das alle drei Compiler unterstützen, verwendet wird.
Dazu gehören Variablen, Funktionen und Expressions sowie If-Else-Statements und Loops. Die Funktion wurde in die jeweiligen Sprachen übersetzt und mehrmals in das Programm eingefügt. Anschliessend wurde jedes Programm zehnmal kompiliert.
Die durchschnittliche Dauer der Kompilierung ist in \ref{fig:compilespeed} ersichtlich.

\begin{figure}[h!]
\centering
\label{fig:compilespeed}
\begin{tikzpicture}
    \begin{axis}[
        enlargelimits=false,
        xlabel=Anzahl der Funktionen,
        xmode=log,
        log basis x=10,
        ylabel=Kompilierungsdauer (ms),
        ymode=log,
        log basis y=10,
        %tick style={draw=none},
        tick label style={font=\bfseries\large},
        grid=major,
        legend pos=north west,
    ]
    \addplot[
        smooth,
        color=blue,
        mark=square,
        mark size=2pt]
    table [col sep=comma]
    {resources/data/compilespeed_qhs.csv};
    \addlegendentry{QHS}
    \addplot[
        smooth,
        color=red,
        mark=square,
        mark size=2pt]
    table [col sep=comma]
    {resources/data/compilespeed_ths.csv};
    \addlegendentry{THS}
    \addplot[
        smooth,
        color=green,
        mark=square,
        mark size=2pt]
    table [col sep=comma]
    {resources/data/compilespeed_c.csv};
    \addlegendentry{GCC}
    \end{axis}
\end{tikzpicture}
\caption{Vergleich der Kompilierungsdauer mit Log-Log Skalen}
\end{figure}

Interessant ist hierbei, dass sowohl QHS als auch GCC mit einer hohen Kompilierungsdauer beginnen und sich später linear verhalten. Während THS zwar zu Beginn mit einer sehr schnellen Kompilierung glänzt,
daraufhin jedoch exponentiell ansteigt. Bei etwas mehr als 10³ Kopien der Funktion wird GCC und daraufhin zwischen 10⁴ und 10⁵ Kopien auch der QHScompiler schneller als der THScompiler. Für die exponentielle Kompilerungsdauer
des THScompilers habe ich leider keine Erklärung. Grundsätzlich sollten alle Schritte, die der THScompiler durchläuft, eine lineare Komplexität aufweisen. Daher liegt der Fehler wahrscheinlich bei meinen eigenen C++ Kenntnissen.
Durch die logarithmischen Skalen erscheint der Unterschied zwischen den Kompilierungsdauern von GCC und dem QHScompiler konstant, jedoch braucht der QHScompiler ab einer Programmgrösse über 10² Funktionskopien konsistent 7-8 mal
länger als GCC. 
Der QHScompiler ist somit deutlich geschlagen. Wie GCC zeigt, liegt das Problem der exponentiellen Kompilierungsdauer beim THScompiler nicht am Prinzip des traditionellen Compilers und viel mehr an meiner Implementation davon.
Daher würde ich in dieser Kategorie des Vergleichs den Sieg für den traditionellen Compiler aussprechen.


\section{Geschwindigkeit eines Programmes}
Die Geschwindigkeit eines kompilierten Programmes wird anhand eines Algorithmus zur Berechnung von Primzahlen gemessen. Sowie bei der Funktion aus Abschnitt \ref{sec:compare-compilespeed} ist dieser Algorithmus so geschrieben,
dass er möglichst jedes von allen drei Compilern unterstütze Feature verwendet. Dieser Algorithmus wurde von Hand in die jeweiligen Sprachen übersetzt.

\begin{figure}[h!]
\centering
\label{fig:executespeed}
\begin{tikzpicture}
    \begin{axis}[
        enlargelimits=false,
        xlabel=Primzahlen bis,
        ylabel=Ausführungsdauer (ms),
        %tick style={draw=none},
        tick label style={font=\bfseries\large},
        grid=major,
        legend pos=north west,
    ]
    \addplot[
        smooth,
        color=blue,
        mark=square,
        mark size=2pt]
    table [col sep=comma]
    {resources/data/executespeed_qhs.csv};
    \addlegendentry{QHS}
    \addplot[
        smooth,
        color=red,
        mark=square,
        mark size=2pt]
    table [col sep=comma]
    {resources/data/executespeed_ths.csv};
    \addlegendentry{THS}
    \addplot[
        smooth,
        color=green,
        mark=square,
        mark size=2pt]
    table [col sep=comma]
    {resources/data/executespeed_c.csv};
    \addlegendentry{C}
    \end{axis}
\end{tikzpicture}
\caption{Vergleich der Ausführungsdauer}
\end{figure}

In Grafik \ref{fig:executespeed} ist ersichtlich, dass (...)


\section{Benutzerfreundlichkeit}
Benutzerfreundlichkeit ist im Gegensatz zu den beiden vorherigen Vergleichskriterien etwas Subjektives. Jedoch würde ich behaupten, dass auch hier das Urteil ziemlich klar ist.
GCC und der THScompiler folgen beide exakt definiertem Syntax und Semantik. Dies ist ein Resultat des Lexers und des Parsers die noch diesen bestimmten Regeln geschrieben wurden.
Anfangs scheinen Semikolons am Ende jedes Statements vielleicht etwas unnötig, jedoch bemerkt man schnell, dass genau diese Pingeligkeit der Compiler für eine Programmiersprache äusserst wichtig ist.
GCC fängt besonders gut Fehler früh ab und meldet diese. Der traditionelle Compiler ist somit sehr gut in puncto Benutzerfreundlichkeit.

Der QHScompiler weisst hier hingegen einige Macken auf. Wie im Abschnitt \ref{sec:qhs-funcs} bereits beschrieben, verfügt der QHScompiler über keine Möglichkeit zu überprüfen, ob eine bestimmte Order folgt oder nicht.
Er führt ganz einfach und strickt nur aus was als Nächstes auftaucht. Somit führt ein fehlendes Zeichen nicht immer zu Fehlern. Folgendes Beispiel kompiliert einwandfrei und lässt sich auch problemlos ausführen.

\begin{lstlisting}[language=QHS, caption=QHS mit fehlenden Tokens, label=eg:qhs-faulty-syntax-1]
int a = "69"    /* ; fehlt */
foo ( a  ;      /* ) fehlt */
\end{lstlisting}

Weder das Semikolon noch die schliessende Klammer bei \ref{eg:qhs-faulty-syntax-1} ist hierbei nötig und das Programm lässt sich problemlos kompilieren und ausführen. Jedoch kann dies auch anders laufen.

\begin{lstlisting}[language=QHS, caption=QHS mit fehlender (, label=eg:qhs-faulty-syntax-2]
int a = "69"    /* ; fehlt */
foo a ) ;       /* ( fehlt */
\end{lstlisting}

Der QHS Code bei \ref{eg:qhs-faulty-syntax-2} kompiliert einwandfrei, jedoch ist der genierte Assembly Code fehlerhaft. Die Funktion foo wird nicht ausgeführt und die Variable a nicht als Argument angesehen.

Weiter sind auch die Fehlermeldungen des QHScompilers nicht immer besonders klar.

\begin{lstlisting}[language=QHS, caption=QHS mit falscher Anzahl Argumente, label=eg:qhs-faulty-syntax-3]
void foo ( ) { }

start
{
    int a = "69" 
    foo ( a ) ;

    exit ;
}

%\noindent\hrulefill Output\noindent\hrulefill%
[ERROR] Cannot dequeue, OrderQueue is empty!
[ERROR] Expected LiteralCode for #literalToIdentifier at OrderQueue second, got: EMPTY
[ERROR] Cannot dequeue, OrderQueue is empty!
[ERROR] Tried #changeIntVar but second order (change) from OrderQueue is not direct code
[ERROR] Expected LiteralCode for #literalToIdentifier, got: EMPTY
[ERROR] Expected LiteralCode for #literalToIdentifier, got: EMPTY
[ERROR] Expected LiteralCode for #literalToIdentifier, got: EMPTY
\end{lstlisting}

Bei \ref{eg:qhs-faulty-syntax-3} wird die Funktion foo ohne Parameter definiert, später jedoch mit einem Argument aufgerufen. Der QHScompiler verfügt hierbei über keine Möglichkeit die Menge an Argumenten zu überprüfen
und meldet nicht direkt einen Fehler. Als er jedoch versucht die Grösse des erwarteten Argumentes von der OrderQueue zu nehmen ist diese leer.
Der QHScompiler meldet also einen OrderQueue-Empty Error gefolgt von vielen Folgefehlern.
Somit ist der QHScompiler einerseits weniger strikt andererseits aber auch deutlich verwirrender und ungenauer als ein traditioneller Compiler.

In meinen Augen triumphiert daher auch in dieser Kategorie der traditionelle Compiler über meinen QHScompiler.

\section{Offenheit für Erweiterung}
Als eine auch professionell verwendete Programmiersprache, hat C selbstverständlich eine Vielzahl an Features. Zum Beispiel lassen sich mithilfe von Templates Datentyp unabhängige Datenstrukturen wie Stacks, Queues oder Vectors definieren.
Weiter lassen sich mit Libraries komplexe Algorithmen einmal schreiben und nachher ganz einfach wieder verwenden. All dies ist innerhalb eines traditionellen Compilers möglich.

Der QHScompiler ist hierbei jedoch noch etwas interessanter. Denn es ist möglich eigene Identifier zu definieren. Mit den im Abschnitt \ref{sec:qhs-funcs} beschriebenen Techniken DelayedExecute und TempAssign
lassen sich sogar selbstständig syntaktisch komplexe Code Strukturen bilden. Im Gegensatz zu einem traditionellen Compiler muss hierfür nicht einmal der QHScompiler angepasst werden.
Es lässt sich also im Grunde eine komplett andere Sprache als QHS ohne jegliche Änderung am QHScompiler definieren. Jedoch ist dies nicht besonders intuitiv und sehr fehleranfällig.

Der QHScompiler ermöglicht einem also grundsätzlich mehr Freiheit. (...)