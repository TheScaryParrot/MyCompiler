#enterOrderQueue
{
#orderEnqueue
#enterOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
{
#exitOrderQueue
#makeOrderQueueProof


#enterOrderQueue
}
#orderEnqueue
#exitOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
}
#exitOrderQueue
#makeOrderQueueProof

{ -> #assignToOne } #assign
{ >> #assign } #assign


{ /* #orderEnqueue #enterComment } >>
{ /* } #makeOrderQueueProof
{ */ #orderEnqueue #exitComment } >>
{ */ } #makeCommentProof
{ */ } #makeOrderQueueProof

{ ; "
" #clearOrderQueue }  >>

{ debug #debug } >> ;

/*
reeeee
debug */


/* { $ #putInFrontFromOrderQueue } >> $ ; */

{ ! } { #orderEnqueue #force } >> ;
{ ! } #makeOrderQueueProof ;

{ lateArg>> } {
    /* result in #orderEnqueue ! in order queue */
    { #orderEnqueue #orderEnqueue #orderEnqueue ! #deepFetch } >> 
} >> ;
{ lateArg>> } #makeOrderQueueProof ;


/* { >> #executeNextInEncounterPhase } >> >>executeOnce ; */

{ start }
{
    text
    resetRBPoffset ;
    "global _start" ;
    "_start:" ;
    "mov rbp, rsp" ;
} >> ;

/* ------------------ data handling ------------------ */
/* types */
{ int } { "4" } >> ;
{ intVar } { var ! int } >> ;

{ bool } { "1" } >> ;
{ boolVar } { var ! bool } >> ;

{ getSizeSpecifier }
{
    #orderFrontEnqueue size ->

    #pushEnv

    { 1 "byte" } >>
    { 2 "word" } >>
    { 4 "dword" } >>
    { 8 "qword" } >>

    { #orderEnqueue ! size } #literalToIdentifier

    #popEnv

} >> ;

{ getRegisterA }
{
    #orderFrontEnqueue size ->

    #pushEnv

    { 1 "al" } >>
    { 2 "ax" } >>
    { 4 "eax" } >>
    { 8 "rax" } >>

    { #orderEnqueue ! size } #literalToIdentifier

    #popEnv    

} >> ;

{ getDefineSpecifier }
{
    #orderFrontEnqueue size ->

    #pushEnv

    { 1 "db" } >>
    { 2 "dw" } >>
    { 4 "dd" } >>
    { 8 "dq" } >>

    { #orderEnqueue ! size } #literalToIdentifier

    #popEnv

} >> ;

/* ------------------ variables ------------------ */
{ varFromDefineCode }
{
    #orderFrontEnqueue defineCode -> ;
    
    { name } lateArg>> ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    { #orderEnqueue ! name }
    { #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode } >> ;

    name ": " defineCode ; 
} >> ;

{ roDataVar }
{
    { size } lateArg>> ;
    { name } lateArg>> ;
    { value } lateArg>> ;

    { defineSpecifier }
    { { #orderEnqueue ! size } getDefineSpecifier }  >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    { #orderEnqueue ! name }
    { #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode } >> ;

    name ": " defineSpecifier " " value ;
} >> ;

{ dataVar }
{
    { size } lateArg>> ;
    { name } lateArg>> ;
    { value } lateArg>> ;

    { defineSpecifier }
    { { #orderEnqueue ! size } getDefineSpecifier } >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    { #orderEnqueue ! name }
    { #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode } >> ;

    name ": " defineSpecifier " " value ;
} >> ;

{ bssVar }
{
    { size } lateArg>> ;
    { name } lateArg>> ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    { #orderEnqueue ! name }
    { #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode } >> ;

    name ": resb " size ;

} >> ;

{ localVar }
{
    { size } lateArg>> ;
    { name } lateArg>> ;
    { value } lateArg>> ;

    { register } { { #orderEnqueue ! size } getRegisterA } >> ;
    { sizeSpecifier } { { #orderEnqueue ! size } getSizeSpecifier } >> ;

    { "rbpOffset" #orderEnqueue ! size } #changeIntVar ;
    { "rbpOffset" currentRBPoffset #orderEnqueue ! #getIntVar } >> ;
    { newRBPvar } { "rbp-" #orderEnqueue ! currentRBPoffset } >> ;
    { address } { "[" #orderEnqueue ! newRBPvar "]" } >> ;

    "sub rsp, " size ;
    "mov " register ", " value ;
    "mov " address ", " register ;

    { #orderEnqueue ! name }
    { #orderEnqueue ! sizeSpecifier " " #orderEnqueue ! address } >> ;
} >> ;

/* ------------------ functions  ------------------ */
{ resetRBPoffset } { { "rbpOffset" "0" } #setIntVar } >> ;

{ funcBodyPreamble }
{
    "mov rbp, rsp" ;
} >> ;

{ funcCallPreamble }
{
    "push rbp" ;
} >> ;

{ funcCallPostamble }
{
    "pop rbp" ;
} >> ;

{ func }
{
    text

    { name } lateArg>> ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    /* 1. pushes forced name; 2. pushed directFuncName (name of new identifier); 3. pushes literal code of 1.; */
    { #orderEnqueue ! name directFuncName #orderEnqueue ! #orderToLiteralCode } >> ;

    /* assign call to the identifer in latearg name */
    { #orderEnqueue ! name }
    { 
        ! funcCallPreamble ;
        "call " directFuncName ;
        ! funcCallPostamble ;
    } >> ;

    resetRBPoffset ;

    directFuncName ":" ;

    funcBodyPreamble ;

} >> ;


{ return }
{
    "mov rsp, rbp" ;
    "ret" ;
} >> ;

/* ------------------ sections ------------------ */
{ rodata }
{ 
    { ".rodata" } #setAssemblySection ;
    { var roDataVar } >> ;
} >> ;

{ data }
{ 
    { ".data" } #setAssemblySection ;
    { var dataVar } >> ;
} >> ;

{ bss }
{ 
    { ".bss" } #setAssemblySection ;
    { var bssVar } >> ;
} >> ;

{ text }
{
    { ".text" } #setAssemblySection ;
    { var localVar } >> ;
} >> ;

/* ------------------ syscalls ------------------ */
{ exit }
{
    "mov rax, 60" ;
    "mov rdi, 0" ;
    "syscall" ;
} >> ;


{ rawPrint }
{
    #orderFrontEnqueue message ->
    #orderFrontEnqueue messageLength -> 

    "mov rax, 1" ;
    "mov rdi, 1" ;
    "mov rsi, " message ;
    "mov rdx, " messageLength ;
    "syscall" ;
} >> ;

{ print }
{
    #orderFrontEnqueue message ->
    #orderFrontEnqueue length -> 

    { register }
    { { #orderEnqueue ! length } getRegisterA } >> ;

    "sub rsp, " length ;
    "mov " register ", " message ;
    "mov [rsp], " register ;

    { "rsp " length } rawPrint ;

    "add rsp, " length ;
} >> ;

{ println }
{
    print ;

    { "0xa" "1" } print ;

} >> ;


/* ------------------ actually coding ------------------ */

/* rodata */
rodata ;

{ "db 'moin', 0xa" } varFromDefineCode wordToGuess ;

{ "equ $ - wordToGuess" } varFromDefineCode wordLength ;

/* data */
data ;

intVar testDataInt "67" ;

/* bss */
bss ;

intVar testBssInt ;

/* text */
/* functions */

func Hello ;

intVar a "68" ;
{ a ! int } println ;

return ;

/* start */
start ;


{ wordToGuess wordLength } rawPrint ;

{ printWord }
{ { wordToGuess wordLength } rawPrint } >> ;

printWord ;

intVar num "65" ; 
intVar num2 "66" ;

{ num ! int } println ;
{ num2 ! int } println ;

{ testDataInt ! int } rawPrint ;

Hello ;

exit ;



