#pushNewOrderQueue
#enterOrderQueue
#pushNewOrderQueue
#pushNextOrderToOrderQueue
#enterOrderQueue
#exitOrderQueue

#assignNextIdentifier
{

#makeNextOrderOrderQueueProof {




#pushNewOrderQueue
#enterOrderQueue
#pushNextOrderToOrderQueue
#exitOrderQueue
#exitOrderQueue

#assignNextIdentifier
}

#makeNextOrderOrderQueueProof }

{ #assignNextIdentifierToOneOrder } #assignNextIdentifier ->
{ #assignNextIdentifier } #assignNextIdentifier >>

{ #pushNextOrderToOrderQueue #enterOrderQueue } >> (
#makeNextOrderOrderQueueProof (
{ #pushNextOrderToOrderQueue #exitOrderQueue } >> )
#makeNextOrderOrderQueueProof )


{ #pushNextOrderToOrderQueue #enterComment } >> /*
#makeNextOrderOrderQueueProof /*
{ #pushNextOrderToOrderQueue #exitComment } >> */
#makeNextOrderOrderQueueProof */
#makeNextOrderCommentProof */

{ "
" #clearOrderQueue }  >> ;

{ #debug } >> debug ;

/*
debug
debug */


{ #putInFrontFromOrderQueue } >> $ ;

{ #pushNextOrderToOrderQueue #escapedReplaceWithOneOrderHandlerStackDepthDeeper } >> @ ;

{
    /* result in #pushNextOrderToOrderQueue ! in order queue */
    { #pushNextOrderToOrderQueue #pushNextOrderToOrderQueue #pushNextOrderToOrderQueue ! @ } >> 
} >> lateArg>> ;
#makeNextOrderOrderQueueProof lateArg>> ;

{ >> #executeNextInEncounterPhase } >> >>executeOnce ;

{ #pushNextOrderToOrderQueue #forceExecuteNextOrder } >> ! ;
#makeNextOrderOrderQueueProof ! ;

{
    /* TODO: Add this */
} >> saveIdentifier ;

{
    /* TODO: Add this */
} >> restoreIdentifier ;

/* swapping */

{ 
    -> second
    ( second )
} >> swap ;

/* ( "1" "2" ) swap

$ $ */

{
    resetRBPoffset ;
    "global _start" ;
    "_start:" ;
    "mov rbp, rsp" ;
} >> start ;

/* ------------------ data handling ------------------ */
/* types */
{ "4" } >> int ;
{ var ! int } >> intVar ;

{ "1" } >> bool ;
{ var ! bool } >> boolVar ;

{ "not good 1" } >> 1 ;
{ "not good 2" } >> 2 ;
{ "not good 4" } >> 4 ;
{ "not good 8" } >> 8 ;

{
    -> size

    { #pushNextOrderToOrderQueue ! 1 } >> _1 
    { #pushNextOrderToOrderQueue ! 2 } >> _2 
    { #pushNextOrderToOrderQueue ! 4 } >> _4 
    { #pushNextOrderToOrderQueue ! 8 } >> _8 

    { "byte" } >> 1
    { "word" } >> 2
    { "dword" } >> 4
    { "qword" } >> 8

    { #pushNextOrderToOrderQueue ! size } #executeDirectCodeFromOrderQueueAsIdentifer

    { #pushNextOrderToOrderQueue ! _1 } >> 1 
    { #pushNextOrderToOrderQueue ! _2 } >> 2 
    { #pushNextOrderToOrderQueue ! _4 } >> 4 
    { #pushNextOrderToOrderQueue ! _8 } >> 8 

} >> getSizeSpecifier ;

{
    -> size

    { #pushNextOrderToOrderQueue ! 1 } >> _1 
    { #pushNextOrderToOrderQueue ! 2 } >> _2 
    { #pushNextOrderToOrderQueue ! 4 } >> _4 
    { #pushNextOrderToOrderQueue ! 8 } >> _8 

    { "al" } >> 1
    { "ax" } >> 2
    { "eax" } >> 4
    { "rax" } >> 8

    { #pushNextOrderToOrderQueue ! size } #executeDirectCodeFromOrderQueueAsIdentifer

    { #pushNextOrderToOrderQueue ! _1 } >> 1 
    { #pushNextOrderToOrderQueue ! _2 } >> 2 
    { #pushNextOrderToOrderQueue ! _4 } >> 4 
    { #pushNextOrderToOrderQueue ! _8 } >> 8 
} >> getRegisterA ;

{
    -> size

    { #pushNextOrderToOrderQueue ! 1 } >> _1 
    { #pushNextOrderToOrderQueue ! 2 } >> _2 
    { #pushNextOrderToOrderQueue ! 4 } >> _4 
    { #pushNextOrderToOrderQueue ! 8 } >> _8 

    { "db" } >> 1
    { "dw" } >> 2
    { "dd" } >> 4
    { "dq" } >> 8

    { #pushNextOrderToOrderQueue ! size } #executeDirectCodeFromOrderQueueAsIdentifer

    { #pushNextOrderToOrderQueue ! _1 } >> 1 
    { #pushNextOrderToOrderQueue ! _2 } >> 2 
    { #pushNextOrderToOrderQueue ! _4 } >> 4 
    { #pushNextOrderToOrderQueue ! _8 } >> 8 
} >> getDefineSpecifier ;

/* ------------------ variables ------------------ */
{
    -> defineCode ;
    
    lateArg>> name ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >>executeOnce name ;

    name ": " defineCode ;
} >> varFromDefineCode ;

{
    lateArg>> size ;
    lateArg>> name ;
    lateArg>> value ;

    { ( #pushNextOrderToOrderQueue ! size ) getDefineSpecifier } >> defineSpecifier ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >>executeOnce name ;

    name ": " defineSpecifier " " value ;
} >> roDataVar

{
    lateArg>> size ;
    lateArg>> name ;
    lateArg>> value ;

    { ( #pushNextOrderToOrderQueue ! size ) getDefineSpecifier } >> defineSpecifier ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >>executeOnce name ;

    name ": " defineSpecifier " " value ;
} >> dataVar ;

{
    
    lateArg>> size ;
    lateArg>> name ;
    /* assigns what is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >>executeOnce name ;

    name ": resb " size ;

} >> bssVar ;

{
    lateArg>> size ;
    lateArg>> name ;
    lateArg>> value ;

    { ( #pushNextOrderToOrderQueue ! size ) getRegisterA } >> register ;
    { ( #pushNextOrderToOrderQueue ! size ) getSizeSpecifier } >> sizeSpecifier ;

    { "rbpOffset" #pushNextOrderToOrderQueue ! size } #changeIntGeneratorVar
    { "rbpOffset" } ( #pushNextOrderToOrderQueue ! #getIntGeneratorVar ) >> currentRBPoffset
    ( "rbp-" #pushNextOrderToOrderQueue ! currentRBPoffset ) >> newRBPvar
    { "[" #pushNextOrderToOrderQueue ! newRBPvar "]" } >> address ;

    "sub rsp, " size ;
    "mov " register ", " value ;
    "mov " address ", " register ;

    { #pushNextOrderToOrderQueue ! sizeSpecifier " " #pushNextOrderToOrderQueue ! address } >>executeOnce name ;
} >> localVar ;

/* ------------------ functions  ------------------ */
{ { "rbpOffset" "0" } #setIntGeneratorVar } >> resetRBPoffset ;

{
    "mov rbp, rsp" ;
} >> funcBodyPreamble ;

{
    "push rbp" ;
} >> funcCallPreamble ;

{
    "pop rbp" ;
} >> funcCallPostamble ;

{
    lateArg>> name ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >> directFuncName ;

    /* assign call to the identifer in latearg name */
    { 
        ! funcCallPreamble ;
        "call " directFuncName ;
        ! funcCallPostamble ;
    } >>executeOnce name ;

    resetRBPoffset ;

    directFuncName ":" ;

    funcBodyPreamble ;

} >> func ;

{
    "mov rsp, rbp" ;
    "ret" ;
} >> return ;

/* ------------------ sections ------------------ */
{ 
    "section .rodata" ; 
    { roDataVar } >> var ;
} >> rodata ;

{ 
    "section .data" ; 
    { dataVar } >> var ;
} >> data ;

{ 
    "section .bss" ;
    { bssVar } >> var ;
} >> bss ;

{
    "section .text"
    { localVar } >> var ;
} >> text ;

/* ------------------ syscalls ------------------ */
{
    "mov rax, 60" ;
    "mov rdi, 0" ;
    "syscall" ;
} >> exit ;


{
    -> message
    -> messageLength
    "mov rax, 1" ;
    "mov rdi, 1" ;
    "mov rsi, " message ;
    "mov rdx, " messageLength ;
    "syscall" ;
} >> rawPrint ;

{
    -> message
    -> length

    { ( #pushNextOrderToOrderQueue ! length ) getRegisterA } >> register ;

    "sub rsp, " length ;
    "mov " register ", " message ;
    "mov [rsp], " register ;

    ( "rsp " length ) rawPrint ;

    "add rsp, " length ;
} >> print ;

{
    print ;

    ( "0xa" "1" ) print ;

} >> println ;


/* ------------------ actually coding ------------------ */

/* rodata */
rodata ;

( "db 'moin', 0xa" ) varFromDefineCode wordToGuess ;

( "equ $ - wordToGuess" ) varFromDefineCode wordLength ;

/* data */
data ;

intVar testDataInt "67" ;

/* bss */
bss ;

intVar testBssInt ;

/* text */
text ;

/* functions */

func Hello ;

intVar a "68" ;
( a ! int ) println ;

return ;

/* start */
start ;


( wordToGuess wordLength ) rawPrint ;

{ ( wordToGuess wordLength ) rawPrint } >> printWord ;

printWord ;

intVar num "65" ; 
intVar num2 "66" ;

( num ! int ) println ;
( num2 ! int ) println ;

( testDataInt ! int ) rawPrint ;

Hello ;

exit ;



