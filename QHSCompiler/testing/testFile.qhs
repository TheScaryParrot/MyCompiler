#pushNewOrderQueue
#enterOrderQueue
#pushNewOrderQueue
#pushNextOrderToOrderQueue
#enterOrderQueue
#exitOrderQueue

#assignNextIdentifier
{

#makeNextOrderOrderQueueProof {




#pushNewOrderQueue
#enterOrderQueue
#pushNextOrderToOrderQueue
#exitOrderQueue
#exitOrderQueue

#assignNextIdentifier
}

#makeNextOrderOrderQueueProof }

{ #assignNextIdentifierToOneOrder } #assignNextIdentifier ->
{ #assignNextIdentifier } #assignNextIdentifier >>

{ #pushNextOrderToOrderQueue #enterOrderQueue } >> (
#makeNextOrderOrderQueueProof (
{ #pushNextOrderToOrderQueue #exitOrderQueue } >> )
#makeNextOrderOrderQueueProof )


{ #pushNextOrderToOrderQueue #enterComment } >> /*
#makeNextOrderOrderQueueProof /*
{ #pushNextOrderToOrderQueue #exitComment } >> */
#makeNextOrderOrderQueueProof */
#makeNextOrderCommentProof */

{ "
" #clearOrderQueue }  >> ;

{ #debug } >> debug ;

/*
debug
debug */


{ #putInFrontFromOrderQueue } >> $ ;

{ #pushNextOrderToOrderQueue #escapedReplaceWithOneOrderHandlerStackDepthDeeper } >> @ ;

{ #pushNextOrderToOrderQueue #forceExecuteNextOrder } >> ! ;
#makeNextOrderOrderQueueProof ! 

/* swapping */

{ 
    -> second
    ( second )
} >> swap ;

/* ( "1" "2" ) swap

$ $ */

{
    "global _start" ;
    "_start:" ;
    "mov rbp, rsp" ;
} >> start ;

{ "section .rodata" } >> rodata ;
{ "section .data" } >> data ;
{ "section .bss" } >> bss ;

{ "section .text" } >> text ;

{ "mov rax, 60
mov rdi, 0
syscall " } >> exit ;


{
    -> message
    -> messageLength
    "mov rax, 1" ;
    "mov rdi, 1" ;
    "mov rsi, " message ;
    "mov rdx, " messageLength ;
    "syscall" ;
} >> rawPrint ;

{
    -> message
    -> length

    "sub rsp, " length ;
    "mov rax, " message ;
    "mov [rsp], rax" ;

    ( "rsp " length ) rawPrint ;

    "add rsp, " length ;
} >> print ;

{
    print ;

    ( "0xa" "1" ) print ;

} >> println ;

{
    -> name
    #makeNextOrderOrderQueueProof name /* make order queue proof so that it is resolved in { name } */

    -> assignCode
    name ": " assignCode ;
    { name } >>
} >> roDataVar 

/* local var */
{
    -> newLocalVarOffset ;

    { #pushNextOrderToOrderQueue ! @ } >> size ;
    { #pushNextOrderToOrderQueue ! @ } >> name ;
    { #pushNextOrderToOrderQueue ! @ } >> value ;

    "sub rsp, " size ;
    "mov rax, " value ;
    { "[rbp-" #pushNextOrderToOrderQueue ! newLocalVarOffset "]" } >> address ;
    "mov " address ", rax" ;

    { #pushNextOrderToOrderQueue ! address } >> #executeNextInEncounterPhase name ;
} >> localVar ;

/* types */
{ "4" } >> int ;
{ "1" } >> bool ;

/* actually coding */

rodata ;

( "wordToGuess" "db 'moin', 0xa" ) roDataVar wordToGuess ;

( "wordLength" "equ $ - wordToGuess" ) roDataVar wordLength ;

data ;

bss ;

text ;
start ;

( wordToGuess wordLength ) rawPrint ;

{ ( wordToGuess wordLength ) rawPrint ; } >> printWord ;

printWord ;


( "4" ) localVar  int num "65" ; 

( num "4" ) println ;



exit ;



