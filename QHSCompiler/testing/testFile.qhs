#pushNewOrderQueue
#enterOrderQueue
#pushNewOrderQueue
#pushNextOrderToOrderQueue
#enterOrderQueue
#exitOrderQueue

#assignNextIdentifier
{

#makeNextOrderOrderQueueProof {




#pushNewOrderQueue
#enterOrderQueue
#pushNextOrderToOrderQueue
#exitOrderQueue
#exitOrderQueue

#assignNextIdentifier
}

#makeNextOrderOrderQueueProof }

{ #assignNextIdentifierToOneOrder } #assignNextIdentifier ->
{ #assignNextIdentifier } #assignNextIdentifier >>

{ #pushNextOrderToOrderQueue #enterOrderQueue } >> (
#makeNextOrderOrderQueueProof (
{ #pushNextOrderToOrderQueue #exitOrderQueue } >> )
#makeNextOrderOrderQueueProof )


{ #pushNextOrderToOrderQueue #enterComment } >> /*
#makeNextOrderOrderQueueProof /*
{ #pushNextOrderToOrderQueue #exitComment } >> */
#makeNextOrderOrderQueueProof */
#makeNextOrderCommentProof */

{ "
" #clearOrderQueue }  >> ;

{ #debug } >> debug ;

/*
debug
debug */


{ #putInFrontFromOrderQueue } >> $ ;

{ #pushNextOrderToOrderQueue #escapedReplaceWithOneOrderHandlerStackDepthDeeper } >> @ ;

{
    /* result in #pushNextOrderToOrderQueue ! in order queue */
    { #pushNextOrderToOrderQueue #pushNextOrderToOrderQueue #pushNextOrderToOrderQueue ! @ } >> 
} >> lateArg>> ;
#makeNextOrderOrderQueueProof lateArg>> ;

{ >> #executeNextInEncounterPhase } >> >>executeOnce ;

{ #pushNextOrderToOrderQueue #forceExecuteNextOrder } >> ! ;
#makeNextOrderOrderQueueProof ! ;

/* swapping */

{ 
    -> second
    ( second )
} >> swap ;

/* ( "1" "2" ) swap

$ $ */

{
    "global _start" ;
    "_start:" ;
    "mov rbp, rsp" ;
} >> start ;

/* variables */
{
    -> assignCode ;

    lateArg>> name ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >>executeOnce name ;

    name ": " assignCode ;
} >> roDataVar

{
    -> assignCode ;

    lateArg>> name ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >>executeOnce name ;

    name ": " assignCode ;
} >> dataVar ;

{
    
    lateArg>> size ;
    lateArg>> name ;
    /* assigns what is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >>executeOnce name ;

    name ": resb " size ;

} >> bssVar ;

{
    -> newLocalVarOffset ;

    lateArg>> size ;
    lateArg>> name ;
    lateArg>> value ;

    "sub rsp, " size ;
    "mov rax, " value ;
    { "[rbp-" #pushNextOrderToOrderQueue ! newLocalVarOffset "]" } >> address ;
    "mov " address ", rax" ;

    { #pushNextOrderToOrderQueue ! address } >>executeOnce name ;
} >> localVar ;

/* functions */
{
    "mov rbp, rsp" ;
} >> funcBodyPreamble ;

{
    "push rbp" ;
} >> funcCallPreamble ;

{
    "pop rbp" ;
} >> funcCallPostamble ;

{
    lateArg>> name ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    { #pushNextOrderToOrderQueue ! #putInFrontNextOrderAsDirectCode #pushNextOrderToOrderQueue #escapedForceExecuteNextOrderInEncounterPhase name } >> directFuncName ;

    /* assign call to the identifer in latearg name */
    { 
        ! funcCallPreamble ;
        "call " directFuncName ;
        ! funcCallPostamble ;
    } >>executeOnce name ;

    directFuncName ":" ;

    funcBodyPreamble ;

} >> func ;

/* sections */
{ 
    "section .rodata" ; 
    { roDataVar } >> var ;
} >> rodata ;

{ 
    "section .data" ; 
    { dataVar } >> var ;
} >> data ;

{ 
    "section .bss" ;
    { bssVar } >> var ;
} >> bss ;

{
    "section .text"
    { localVar } >> var ;
} >> text ;

/* syscalls */
{
    "mov rax, 60" ;
    "mov rdi, 0" ;
    "syscall" ;
} >> exit ;


{
    -> message
    -> messageLength
    "mov rax, 1" ;
    "mov rdi, 1" ;
    "mov rsi, " message ;
    "mov rdx, " messageLength ;
    "syscall" ;
} >> rawPrint ;

{
    -> message
    -> length

    "sub rsp, " length ;
    "mov rax, " message ;
    "mov [rsp], rax" ;

    ( "rsp " length ) rawPrint ;

    "add rsp, " length ;
} >> print ;

{
    print ;

    ( "0xa" "1" ) print ;

} >> println ;


/* types */
{ "4" } >> int ;
{ "1" } >> bool ;

/* actually coding */

/* rodata */
rodata ;

( "db 'moin', 0xa" ) var wordToGuess ;

( "equ $ - wordToGuess" ) var wordLength ;

/* data */
data ;

( "dd 67" ) var testDataInt ;

/* bss */
bss ;

var int testBssInt ;

/* text */
text ;

/* functions */

func Hello ;

( "4" ) var int a "68" ;
( a "4" ) println ;

"mov rsp, rbp" ;
"ret" ;

/* start */
start ;


( wordToGuess wordLength ) rawPrint ;

{ ( wordToGuess wordLength ) rawPrint ; } >> printWord ;

printWord ;

{ var int } >> intVar ;

( "4" ) intVar num "65" ; 
/* ( "8" ) localVar int num2 "66" ; */

( num "4" ) println ;
/* ( num2 "4" ) println ; */

( testDataInt "4" ) rawPrint ;

Hello ;

exit ;



