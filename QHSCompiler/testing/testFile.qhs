#enterOrderQueue
(
#orderEnqueue
#enterOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
(
#exitOrderQueue
#makeOrderQueueProof


#enterOrderQueue
)
#orderEnqueue
#exitOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
)
#exitOrderQueue
#makeOrderQueueProof

( -> #assignToOne ) #assign
( >> #assign ) #assign


( /* #orderEnqueue #enterComment ) >>
( /* ) #makeOrderQueueProof
( */ #orderEnqueue #exitComment ) >>
( */ ) #makeCommentProof
( */ ) #makeOrderQueueProof

( ; "
" #clearOrderQueue )  >>

( debug #debug ) >> ;

/*
reeeee
debug */


( ! ) ( #orderEnqueue #force ) >> ;
( ! ) #makeOrderQueueProof ;

( lateArg>> ) (
    /* result in #orderEnqueue ! in order queue */
    ( #orderEnqueue #orderEnqueue #orderEnqueue ! #deepFetch ) >> 
) >> ;
( lateArg>> ) #makeOrderQueueProof ;

( start )
(
    #pushEnv
    ( var localVar ) >>
    ( { ) >> /* { to none */
    ( } #popEnv ) >> /* } to end of function body */

    ( ".text" ) #setAssemblySection 
    resetRBPoffset ;
    "global _start" ;
    "_start:" ;
    "mov rbp, rsp" ;
) >> ;

/* ------------------ data handling ------------------ */
/* types */
( int.size ) ( "4" ) >> ;
( int ) ( ( ! int.size ) var ) >> 

( bool.size ) ( "1" ) >> ;
( bool ) ( ( ! bool.size ) var ) >>

( getSizeSpecifier )
(
    #orderFrontEnqueue size ->

    #pushEnv

    ( 1 "byte" ) >>
    ( 2 "word" ) >>
    ( 4 "dword" ) >>
    ( 8 "qword" ) >>

    ( #orderEnqueue ! size ) #literalToIdentifier

    #popEnv

) >> ;

( getRegisterA )
(
    #orderFrontEnqueue size ->

    #pushEnv

    ( 1 "al" ) >>
    ( 2 "ax" ) >>
    ( 4 "eax" ) >>
    ( 8 "rax" ) >>

    ( #orderEnqueue ! size ) #literalToIdentifier

    #popEnv    

) >> ;

( getDefineSpecifier )
(
    #orderFrontEnqueue size ->

    #pushEnv

    ( 1 "db" ) >>
    ( 2 "dw" ) >>
    ( 4 "dd" ) >>
    ( 8 "dq" ) >>

    ( #orderEnqueue ! size ) #literalToIdentifier

    #popEnv

) >> ;

/* ------------------ variables ------------------ */
( varFromDefineCode )
(
    #orderFrontEnqueue defineCode -> ;
    
    ( name ) lateArg>> ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    ( #orderEnqueue ! name )
    ( #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ) >> ;

    name ": " defineCode ; 
) >> ;

( roDataVar )
(
    ( size ) lateArg>> ;
    ( name ) lateArg>> ;
    ( value ) lateArg>> ;

    ( defineSpecifier )
    ( ( #orderEnqueue ! size ) getDefineSpecifier )  >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    ( #orderEnqueue ! name )
    ( #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ) >> ;

    name ": " defineSpecifier " " value ;
) >> ;

( dataVar )
(
    #orderFrontEnqueue ".data" #setAssemblySection

    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->
    #orderFrontEnqueue value ->

    ( defineSpecifier )
    ( ( #orderEnqueue ! size ) getDefineSpecifier ) >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    ( #orderEnqueue ! name )
    ( #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ) >> ;

    name ": " defineSpecifier " " value ;
) >> ;

( bssVar )
(
    #orderFrontEnqueue ".bss" #setAssemblySection

    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->

    /* assigns what is stored in name to the direct code of what is stored in name */
    ( #orderEnqueue ! name )
    ( #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ) >> ;

    name ": resb " size ;

) >> ;

( assign )
(
    #orderFrontEnqueue size ->
    #orderFrontEnqueue location ->
    #orderFrontEnqueue value ->

    ( register ) ( ( #orderEnqueue ! size ) getRegisterA ) >>

    "mov " register ", " value ;
    "mov " location ", " register ;
) >>

( localVar )
(
    #orderFrontEnqueue size ->
    ( name ) lateArg>> ;

    ( sizeSpecifier ) ( ( #orderEnqueue ! size ) getSizeSpecifier ) >> ;

    ( "rbpOffset" #orderEnqueue ! size ) #changeIntVar ;
    ( "rbpOffset" currentRBPoffset #orderEnqueue ! #getIntVar ) >> ;
    ( newRBPvar ) ( "rbp-" #orderEnqueue ! currentRBPoffset ) >> ;
    ( address ) ( "[" #orderEnqueue ! newRBPvar "]" ) >> ;

    "sub rsp, " size ;

    ( #orderEnqueue ! name )
    ( #orderEnqueue ! sizeSpecifier " " #orderEnqueue ! address ) >> ;

    #pushEnv
    
    ( = )
    (
        #popEnv

        ( #orderEnqueue ! size )
        ( #orderEnqueue ! name )
        ( #orderEnqueue #orderEnqueue #orderEnqueue ! #deepFetch )
        
        assign
    ) >>

    ( ; )
    (
        #popEnv
        ;
    ) >> 
) >> ;



( globalVar )
(
    
    #orderFrontEnqueue size ->

    #pushEnv

    ( = )
    (
        #popEnv

        /* enqueue next from inputfile order queue (value) */
        ( #orderEnqueue #orderEnqueue #orderEnqueue ! #deepFetch )

        dataVar ;
    ) >>

    ( ; )
    (
        #popEnv

        bssVar ;
    ) >>

    /* enqueue size */
    ( #orderEnqueue ! size )

    /* enqueue next from inputfile order queue (name) */
    ( #orderEnqueue ! #deepFetch )

) >> ;

/* when making a var globalVar is used */
( var globalVar ) >> ;

/* ------------------ functions  ------------------ */
( resetRBPoffset ) ( ( "rbpOffset" "0" ) #setIntVar ) >> ;

( funcBodyPreamble )
(
    "mov rbp, rsp" ;
) >> ;

( funcCallPreamble )
(
    "push rbp" ;
) >> ;

( funcCallPostamble )
(
    "pop rbp" ;
) >> ;

( func )
(
    ( name ) lateArg>> ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    /* 1. pushes forced name; 2. pushed directFuncName (name of new identifier); 3. pushes literal code of 1.; */
    ( #orderEnqueue ! name directFuncName #orderEnqueue ! #orderToLiteralCode ) >> ;

    /* assign call to the identifer in latearg name */
    ( #orderEnqueue ! name )
    ( 
        ! funcCallPreamble ;
        "call " directFuncName ;
        ! funcCallPostamble ;
    ) >> ;

    #pushEnv
    ( var localVar ) >>
    ( { ) >> /* { to none */
    ( } #popEnv ) >> /* } to end of function body */

    ( ".text" ) #setAssemblySection
    resetRBPoffset ;

    directFuncName ":" ;

    funcBodyPreamble ;

) >> ;


( return )
(
    "mov rsp, rbp" ;
    "ret" ;
) >> ;

/* ------------------ syscalls ------------------ */
( exit )
(
    "mov rax, 60" ;
    "mov rdi, 0" ;
    "syscall" ;
) >> ;

( rawPrint )
(
    #orderFrontEnqueue message ->
    #orderFrontEnqueue messageLength -> 

    "mov rax, 1" ;
    "mov rdi, 1" ;
    "mov rsi, " message ;
    "mov rdx, " messageLength ;
    "syscall" ;
) >> ;

( print )
(
    #orderFrontEnqueue message ->
    #orderFrontEnqueue length -> 

    ( register )
    ( ( #orderEnqueue ! length ) getRegisterA ) >> ;

    "sub rsp, " length ;
    "mov " register ", " message ;
    "mov [rsp], " register ;

    ( "rsp" length ) rawPrint ;

    "add rsp, " length ;
) >> ;

( println )
(
    print ;

    ( "0xa" "1" ) print ;

) >> ;


/* ------------------ actually coding ------------------ */

int bssInt ;

int dataInt = "69" ;

( ".rodata" ) #setAssemblySection
( "db 'moin', 0xa" ) varFromDefineCode wordToGuess ;
( "equ $ - wordToGuess" ) varFromDefineCode wordLength ;

/* functions */

func Hello
{
    int a = "68" ;
    ( a ! int.size ) println ;

    return ;
}

/* start */
start
{
    ( wordToGuess wordLength ) rawPrint ;

    ( printWord )
    ( ( wordToGuess wordLength ) rawPrint ) >> ;

    printWord ;

    int num = "65" ; 
    int num2 = "66" ;

    ( num ! int.size ) println ;
    ( num2 ! int.size ) println ;

    
    ( dataInt ! int.size ) rawPrint ;

    Hello ;

    exit ;
}



