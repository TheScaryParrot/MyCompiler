#enterOrderQueue
[
#orderEnqueue
#enterOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
[
#exitOrderQueue
#makeOrderQueueProof


#enterOrderQueue
]
#orderEnqueue
#exitOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
]
#exitOrderQueue
#makeOrderQueueProof

[ -> #assignToOne ] #assign
[ >> #assign ] #assign


[ /* #orderEnqueue #enterComment ] >>
[ /* ] #makeOrderQueueProof
[ */ #orderEnqueue #exitComment ] >>
[ */ ] #makeCommentProof
[ */ ] #makeOrderQueueProof

[ ; "
" #clearOrderQueue ]  >>


[ ! ] [ #orderEnqueue #force ] >> ;
[ ! ] #makeOrderQueueProof ;

[ ?! ] [ #orderEnqueue #lightForce ] >> ;
[ ?! ] #makeOrderQueueProof ;

[ lateArg>> ] [
    /* result in #orderEnqueue ! in order queue */
    [ #orderEnqueue #orderEnqueue #orderEnqueue ! #deepFetch ] >> 
] >> ;
[ lateArg>> ] #makeOrderQueueProof ;

/* ------------------ data handling ------------------ */
/* types */
[ int.size ] [ "4" ] >> ;
[ int ] [ [ ! int.size ] definition ] >> 

[ bool.size ] [ "1" ] >> ;
[ bool ] [ [ ! bool.size ] definition ] >>

[ void ] [ [ "0" ] definition ] >>

/* assembly stuff */
[ getSizeSpecifier ]
[
    #orderFrontEnqueue size ->

    #pushEnv

    [ 1 "byte" ] >>
    [ 2 "word" ] >>
    [ 4 "dword" ] >>
    [ 8 "qword" ] >>

    [ #orderEnqueue ! size ] #literalToIdentifier

    #popEnv

] >> ;

[ getRegisterA ]
[
    #orderFrontEnqueue size ->

    #pushEnv

    [ 1 "al" ] >>
    [ 2 "ax" ] >>
    [ 4 "eax" ] >>
    [ 8 "rax" ] >>

    [ #orderEnqueue ! size ] #literalToIdentifier

    #popEnv    

] >> ;

[ getDefineSpecifier ]
[
    #orderFrontEnqueue size ->

    #pushEnv

    [ 1 "db" ] >>
    [ 2 "dw" ] >>
    [ 4 "dd" ] >>
    [ 8 "dq" ] >>

    [ #orderEnqueue ! size ] #literalToIdentifier

    #popEnv

] >> ;

/* ------------------ definitions ------------------ */

[ globalDefinition ]
[
    #orderFrontEnqueue size ->
    [ name ] lateArg>>

    #pushEnv

    [ = ]
    [
        #popEnv

        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]
        [ ?! expr ]

        dataVar ;
    ] >>

    [ ; ]
    [
        #popEnv

        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]

        bssVar ;
    ] >>

    [ ( ]
    [
        #popEnv

        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]

        defineFuncIdentifier ;

        #pushEnv

        /* redefine var a parameter definition */
        initParameterDefinition ;

        [ ) ]
        [
            [ #orderEnqueue ! name ]
            funcBody ;
        ] >>

        /* define , as nothing */
        [ , ] [ ] >>
    ] >>

] >> ;

/* variables  */
[ varFromDefineCode ]
[
    #orderFrontEnqueue defineCode -> ;
    
    [ name ] lateArg>> ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": " defineCode ; 
] >> ;

[ roDataVar ]
[
    [ size ] lateArg>> ;
    [ name ] lateArg>> ;
    [ value ] lateArg>> ;

    [ defineSpecifier ]
    [ [ #orderEnqueue ! size ] getDefineSpecifier ]  >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": " defineSpecifier " " value ;
] >> ;

[ dataVar ]
[
    #orderFrontEnqueue ".data" #setAssemblySection

    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->
    #orderFrontEnqueue value ->

    [ defineSpecifier ]
    [ [ #orderEnqueue ! size ] getDefineSpecifier ] >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": " defineSpecifier " " value ;
] >> ;

[ bssVar ]
[
    #orderFrontEnqueue ".bss" #setAssemblySection

    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->

    /* assigns what is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": resb " size ;

] >> ;

[ assign ]
[
    #orderFrontEnqueue size ->
    #orderFrontEnqueue location ->
    #orderFrontEnqueue value ->

    [ register ] [ [ #orderEnqueue ! size ] getRegisterA ] >>

    "mov " register ", " value ;
    "mov " location ", " register ;
] >>

[ localVar ]
[
    #orderFrontEnqueue size ->
    [ name ] lateArg>> ;

    [ sizeSpecifier ] [ [ #orderEnqueue ! size ] getSizeSpecifier ] >> ;

    [ "rbpOffset" #orderEnqueue ! size ] #changeIntVar ;
    [ "rbpOffset" currentRBPoffset #orderEnqueue ! #getIntVar ] >> ;
    [ newRBPvar ] [ "rbp-" #orderEnqueue ! currentRBPoffset ] >> ;
    [ address ] [ "[" #orderEnqueue ! newRBPvar "]" ] >> ;

    "sub rsp, " size ;

    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! sizeSpecifier " " #orderEnqueue ! address ] >> ;

    #pushEnv
    
    [ = ]
    [
        #popEnv

        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]
        [ #orderEnqueue #orderEnqueue #orderEnqueue ! expr ]
        
        assign
    ] >>

    [ ; ]
    [
        #popEnv
        ;
    ] >> 
] >> ;

/* defintion current is globalDefinition */
[ definition globalDefinition ] >> ;

/* functions */
[ resetRBPoffset ] [ [ "rbpOffset" "0" ] #setIntVar ] >> ;

[ funcBodyPreamble ]
[
    "mov rbp, rsp" ;
] >> ;

[ funcCallPreamble ]
[
    "push rbp" ;
] >> ;

[ funcCallPostamble ]
[
    "pop rbp" ;
] >> ;

[ start ]
[
    #pushEnv
    [ definition localVar ] >>
    [ { ] >> /* { to none */
    [ } #popEnv ] >> /* } to end of function body */

    [ ".text" ] #setAssemblySection 
    resetRBPoffset ;
    "global _start" ;
    "_start:" ;
    "mov rbp, rsp" ;
] >> ;

[ defineFuncIdentifier ]
[
    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->

    #clearOrderQueue /* it should be empty but you never know */

    /* funcLabel = name as literalCode */
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] #orderFrontEnqueue funcLabel >> 


    /* name = name() as identifier */
    [ #orderEnqueue ! funcLabel "()" ] [ #orderEnqueue ! #literalCombine ]
    [ #orderEnqueue ! #literalToIdentifier ] #orderFrontEnqueue name >> 

    /* name() = call name generated from funcCall identifier */
    [ #orderEnqueue ! name ]
    [ 
        [ #orderEnqueue ! funcLabel ] funcCall
    ] >> ;
] >> 

[ funcBody ]
[
    #orderFrontEnqueue name -> 
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] #orderFrontEnqueue funcLabel >> 

    [ definition localVar ] >>
    [ { ] >> /* { to none */
    [ } #popEnv ] >> /* } to end of function body */

    [ ".text" ] #setAssemblySection
    resetRBPoffset ;

    funcLabel ":" ;

    funcBodyPreamble ;
] >>

[ initParameterDefinition ]
[
    /* definitions now are parameterDefinition */
    [ definition parameterDefinition ] >>

    /* rbpOffset = 16 */
    [ "rbpOffset" "16 "] #setIntVar ;
] >>

[ parameterDefinition ]
[
    #orderFrontEnqueue size ->
    [ name ] lateArg>> ;

    [ sizeSpecifier ] [ [ #orderEnqueue ! size ] getSizeSpecifier ] >> ;

    /* first get RBPoffset then rbpOffset += size */
    [ "rbpOffset" currentRBPoffset #orderEnqueue ! #getIntVar ] >> ;
    [ "rbpOffset" #orderEnqueue ! size ] #changeIntVar ;
    /* parameter is at rbp+offset */
    [ newRBPvar ] [ "rbp+" #orderEnqueue ! currentRBPoffset ] >> ;
    [ address ] [ "[" #orderEnqueue ! newRBPvar "]" ] >> ;

    "sub rsp, " size ;

    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! sizeSpecifier " " #orderEnqueue ! address ] >> ;
] >>

[ funcCall ]
[
    #orderFrontEnqueue funcLabel -> 

    ! funcCallPreamble ;
    "call " funcLabel ;
    ! funcCallPostamble ;
] >>

[ return ]
[
    "mov rsp, rbp" ;
    "ret" ;
] >> ;

/* expressions */

[ expr ]
[
    /* TODO: Implement operators */
    /* current just a deepFetch */
    #orderEnqueue ! #deepFetch
] >>

/* ------------------ syscalls ------------------ */
[ exit ]
[
    "mov rax, 60" ;
    "mov rdi, 0" ;
    "syscall" ;
] >> ;

[ rawPrint ]
[
    #orderFrontEnqueue message ->
    #orderFrontEnqueue messageLength -> 

    "mov rax, 1" ;
    "mov rdi, 1" ;
    "mov rsi, " message ;
    "mov rdx, " messageLength ;
    "syscall" ;
] >> ;

[ print ]
[
    #orderFrontEnqueue message ->
    #orderFrontEnqueue length -> 

    [ register ]
    [ [ #orderEnqueue ! length ] getRegisterA ] >> ;

    "sub rsp, " length ;
    "mov " register ", " message ;
    "mov [rsp], " register ;

    [ "rsp" length ] rawPrint ;

    "add rsp, " length ;
] >> ;

[ println ]
[
    print ;

    [ "0xa" "1" ] print ;

] >> ;


/* ------------------ actually coding ------------------ */

int bssInt ;

int dataInt = "69" ;

[ ".rodata" ] #setAssemblySection
[ "db 'moin', 0xa" ] varFromDefineCode wordToGuess ;
[ "equ $ - wordToGuess" ] varFromDefineCode wordLength ;

/* functions */

void Hello ( int p1 , bool p2 )
{
    int a = "68" ;
    [ a ! int.size ] println ;

    return ;
}

/* start */
start
{
    [ wordToGuess wordLength ] rawPrint ;

    [ printWord ]
    [ [ wordToGuess wordLength ] rawPrint ] >> ;

    printWord ;

    int num = "65" ; 
    int num2 = "66" ;

    [ num ! int.size ] println ;
    [ num2 ! int.size ] println ;

    
    [ dataInt ! int.size ] rawPrint ;

    Hello() ;

    exit ;
}



