#enterOrderQueue
[
#orderEnqueue
#enterOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
[
#exitOrderQueue
#makeOrderQueueProof


#enterOrderQueue
]
#orderEnqueue
#exitOrderQueue
#exitOrderQueue

#assign

#enterOrderQueue
]
#exitOrderQueue
#makeOrderQueueProof

[ -> #assignToOne ] #assign
[ >> #assign ] #assign

[ debugOrderQueue ]
[
    #activateDebug
    #debugOrderQueue
    #deactivateDebug
] >>


[ /* #orderEnqueue #enterComment ] >>
[ /* ] #makeOrderQueueProof
[ */ #orderEnqueue #exitComment ] >>
[ */ ] #makeCommentProof
[ */ ] #makeOrderQueueProof

[ ; "
" #clearOrderQueue ]  >>


[ ! ] [ #orderEnqueue #force ] >> ;
[ ! ] #makeOrderQueueProof ;

[ ?! ] [ #orderEnqueue #lightForce ] >> ;
[ ?! ] #makeOrderQueueProof ;

[ lateArg>> ] [
    /* result in #orderEnqueue ! in order queue */
    [ #orderEnqueue #orderEnqueue #orderEnqueue ! #deepFetch ] >> 
] >> ;
[ lateArg>> ] #makeOrderQueueProof ;

/* ------------------ data handling ------------------ */
/* types */
[ int.size ] [ "4" ] >> ;
[ int ] [ [ ! int.size ] definition ] >> 

[ bool.size ] [ "1" ] >> ;
[ bool ] [ [ ! bool.size ] definition ] >>

[ void ] [ [ "0" ] definition ] >>

/* assembly stuff */
[ getSizeSpecifier ]
[
    #orderFrontEnqueue size ->

    #pushEnv

    [ 1 "byte" ] >>
    [ 2 "word" ] >>
    [ 4 "dword" ] >>
    [ 8 "qword" ] >>

    [ #orderEnqueue ! size ] #literalToIdentifier

    #popEnv

] >> ;

[ getRegisterA ]
[
    #orderFrontEnqueue size ->

    #pushEnv

    [ 1 "al" ] >>
    [ 2 "ax" ] >>
    [ 4 "eax" ] >>
    [ 8 "rax" ] >>

    [ #orderEnqueue ! size ] #literalToIdentifier

    #popEnv    

] >> ;

[ getDefineSpecifier ]
[
    #orderFrontEnqueue size ->

    #pushEnv

    [ 1 "db" ] >>
    [ 2 "dw" ] >>
    [ 4 "dd" ] >>
    [ 8 "dq" ] >>

    [ #orderEnqueue ! size ] #literalToIdentifier

    #popEnv

] >> ;

/* ------------------ definitions ------------------ */

[ globalDefinition ]
[
    #orderFrontEnqueue size ->
    [ name ] lateArg>>

    #pushEnv

    [ = ]
    [
        #popEnv

        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]
        [ ?! expr ]

        dataVar ;
    ] >>

    [ ; ]
    [
        #popEnv

        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]

        bssVar ;
    ] >>

    [ ( ]
    [
        #popEnv

        #pushEnv

        [ _functionDefinitionOrderQueue ]
        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]
        >>
        
        initParameterDefinition ;

        [ ) ]
        [
            [ #orderEnqueue ! name ]
            funcBody ;
        ] >>

        [ , ] >> /* , = nothing */
    ] >>

] >> ;

/* variables  */
[ varFromDefineCode ]
[
    #orderFrontEnqueue defineCode -> ;
    
    [ name ] lateArg>> ;

    /* assigns what is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": " defineCode ; 
] >> ;

[ roDataVar ]
[
    [ size ] lateArg>> ;
    [ name ] lateArg>> ;
    [ value ] lateArg>> ;

    [ defineSpecifier ]
    [ [ #orderEnqueue ! size ] getDefineSpecifier ]  >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": " defineSpecifier " " value ;
] >> ;

[ dataVar ]
[
    #orderFrontEnqueue ".data" #setAssemblySection

    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->
    #orderFrontEnqueue value ->

    [ defineSpecifier ]
    [ [ #orderEnqueue ! size ] getDefineSpecifier ] >> ;

    /* assigns whast is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": " defineSpecifier " " value ;
] >> ;

[ bssVar ]
[
    #orderFrontEnqueue ".bss" #setAssemblySection

    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->

    /* assigns what is stored in name to the direct code of what is stored in name */
    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] >> ;

    name ": resb " size ;

] >> ;

[ assign ]
[
    #orderFrontEnqueue size ->
    #orderFrontEnqueue location ->
    #orderFrontEnqueue value ->

    [ register ] [ [ #orderEnqueue ! size ] getRegisterA ] >>

    "mov " register ", " value ;
    "mov " location ", " register ;
] >>

[ localVar ]
[
    #orderFrontEnqueue size ->
    [ name ] lateArg>> ;

    [ sizeSpecifier ] [ [ #orderEnqueue ! size ] getSizeSpecifier ] >> ;

    [ "rbpOffset" #orderEnqueue ! size ] #changeIntVar ;
    [ "rbpOffset" currentRBPoffset #orderEnqueue ! #getIntVar ] >> ;

    /* ! name = sizeSpecifier [rbp-offset] */
    [ ?! size ]
    [ ?! name ]
    [ ?! sizeSpecifier " [rbp-" ?! currentRBPoffset "]" ] 
    defineVarIdentifier ;

    "sub rsp, " size ;

    #pushEnv
    
    [ = ]
    [
        #popEnv

        [ #orderEnqueue ! size ]
        [ #orderEnqueue ! name ]
        [ #orderEnqueue #orderEnqueue #orderEnqueue ! expr ]
        
        assign
    ] >>

    [ ; ]
    [
        #popEnv
        ;
    ] >> 
] >> ;

/* return on OrderQueue */
[ varSize ]
[
    #orderFrontEnqueue variabel ->

    [ ?! variabel ?! #orderToLiteralCode ".size" ?! #literalCombine ?! #literalToIdentifier ] [ ?! #executeOrderTop ]
] >>

/* expects Queue top as size, rest the identifier Assign for the identifier */
[ defineVarIdentifier ]
[
    #orderFrontEnqueue size ->
    #orderFrontEnqueue identifier ->
    #orderFrontEnqueue value >>
    
    [ ?! identifier ?! value ] >>

    /* IDENTIFIER.size = size */
    [ ?! identifier ?! #orderToLiteralCode ".size" ?! #literalCombine ?! #literalToIdentifier ] [ ?! size ] >>
] >>

/* defintion current is globalDefinition */
[ definition globalDefinition ] >> ;

/* functions */
[ resetRBPoffset ] [ [ "rbpOffset" "0" ] #setIntVar ] >> ;

[ start ]
[
    #pushEnv
    [ definition localVar ] >>
    [ { ] >> /* { to none */
    [ } #popEnv ] >> /* } to end of function body */

    [ ".text" ] #setAssemblySection 
    resetRBPoffset ;
    "global _start" ;
    "_start:" ;
    "mov rbp, rsp" ;
] >> ;

[ defineFuncIdentifier ]
[
    /* TODO use size for return */
    #orderFrontEnqueue size ->
    #orderFrontEnqueue name ->
    #orderFrontEnqueue parameterSizes >>

    [ "paramSize" ?! #getIntVar ] #orderFrontEnqueue paramSize >>

    #clearOrderQueue /* it should be empty but you never know */

    /* funcLabel = name as literalCode */
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] #orderFrontEnqueue funcLabel >> 

    /* name() = call name generated from funcCall identifier */
    [ #orderEnqueue ! name ]
    [
        [ #orderEnqueue ! funcLabel #orderEnqueue ! paramSize #orderEnqueue ! parameterSizes ] 
        funcCall
    ] >> ;
] >> 

[ funcBody ]
[
    #orderFrontEnqueue name -> 
    [ #orderEnqueue ! name #orderEnqueue ! #orderToLiteralCode ] #orderFrontEnqueue funcLabel >> 

    [ definition localVar ] >>
    [ { ] >> /* { = none */
    [ } funcBodyEnd ] >> /* } = end of function body */

    [ ".text" ] #setAssemblySection
    resetRBPoffset ;

    funcLabel ":" ;
    "mov rbp, rsp" ;
] >>

[ funcBodyEnd ]
[
    [ ?! _functionDefinitionOrderQueue ]

    #popEnv

    defineFuncIdentifier
] >>

[ initParameterDefinition ]
[
    /* definitions now are parameterDefinition */
    [ definition parameterDefinition ] >>

    /* rbpOffset = 16 */
    [ "rbpOffset" "16 "] #setIntVar ;

    /* paramSize = 0 */
    [ "paramSize" "0" ] #setIntVar ;
] >>

[ parameterDefinition ]
[
    #orderFrontEnqueue size ->
    [ name ] lateArg>> ;

    [ sizeSpecifier ] [ [ #orderEnqueue ! size ] getSizeSpecifier ] >> ;

    /* first get RBPoffset then rbpOffset += size */
    [ "rbpOffset" currentRBPoffset #orderEnqueue ! #getIntVar ] >> ;
    [ "rbpOffset" #orderEnqueue ! size ] #changeIntVar ;

    /* paramSize += size */
    [ "paramSize" #orderEnqueue ! size ] #changeIntVar ;

    /* parameter is at rbp+offset */
    [ newRBPvar ] [ "rbp+" #orderEnqueue ! currentRBPoffset ] >> ;
    [ address ] [ "[" #orderEnqueue ! newRBPvar "]" ] >> ;

    "sub rsp, " size ;

    [ #orderEnqueue ! name ]
    [ #orderEnqueue ! sizeSpecifier " " #orderEnqueue ! address ] >> ;

    [ _functionDefinitionOrderQueue #orderEnqueue ! _functionDefinitionOrderQueue #orderEnqueue ! size ] >>
] >>

/* call with with arguments */
[ funcCall ]
[
    #pushEnv

    #orderFrontEnqueue funcLabel ->
    /* combined size of all arguments */
    #orderFrontEnqueue argSize ->

    #orderFrontEnqueue argSizes >>

    [ () ]
    [
        #popEnv
        [ #orderEnqueue ! funcLabel ] literalCall ;
    ] >>

    [ ) ]
    [
        #popEnv
        [ #orderEnqueue ! funcLabel #orderEnqueue ! argSize ] literalCall ;
    ] >>

    [ ( ]
    [
        [ ?! argSize ]
        initArguments

        /* size = first order stored in argSizes */
        [ size ] [ ?! argSizes ] ->
        #orderFrontEnqueue argSizes >>

        /* argument need to be last instruction as otherwise the expr call in argument would get something from this */
        [ ?! size ] argument
    ] >>

    [ , ]
    [
        [ size ] [ ?! argSizes ] ->
        #orderFrontEnqueue argSizes >>

        /* argument need to be last instruction as otherwise the expr call in argument would get something from this */
        [ ?! size ] argument
    ] >>
] >>

/* just the call assembly code */
[ literalCall ]
[
    #orderFrontEnqueue funcLabel -> 
    #orderFrontEnqueue argSize ->

    "push rbp" ;
    "call " funcLabel ;
    "pop rbp" ;
    "add rsp, " argSize ;
] >>

[ initArguments ]
[
    #orderFrontEnqueue argSize ->

    [ "argOffset" #orderEnqueue ! currentRBPoffset ] #setIntVar
    [ "argOffset" #orderEnqueue ! argSize ] #changeIntVar

    "sub rsp, " argSize ;
] >>

[ argument ]
[
    #orderFrontEnqueue size ->
    [ value ?! expr ] >> 

    [ sizeSpecifier ] [ [ #orderEnqueue ! size ] getSizeSpecifier ] >>

    /* currentArgoffset = argOffset var */
    [ "argOffset" currentArgOffset ?! #getIntVar ] >>
    /* argument is at rbp-offset */
    [ newLocation ] [ ?! sizeSpecifier " [rbp-" ?! currentArgOffset "]" ] >>

    /* change arg offset, which was set in initArguments */
    /* changes argOffset by -size */
    [ "-" ?! size ?! #literalCombine ] 
    #orderFrontEnqueue "argOffset" #changeIntVar ;

    [ ?! size ] [ newLocation ] [ ?! value ] assign ;
] >>

[ return ]
[
    "mov rsp, rbp" ;
    "ret" ;
] >> ;

/* expressions */

[ expr ]
[
    /* TODO: Implement operators */
    /* current just a deepFetch */
    #orderEnqueue ! #deepFetch
] >>

[ = ]
[
    #pushEnv
    #orderFrontEnqueue var ->

    [ ?! var ] varSize
    [ ?! var ]
    [ #orderEnqueue ! #deepFetch ] 
    assign ;
    #popEnv
] >>

/* ------------------ syscalls ------------------ */
[ exit ]
[
    "mov rax, 60" ;
    "mov rdi, 0" ;
    "syscall" ;
] >> ;

[ rawPrint ]
[
    #orderFrontEnqueue message ->
    #orderFrontEnqueue messageLength -> 

    "mov rax, 1" ;
    "mov rdi, 1" ;
    "mov rsi, " message ;
    "mov rdx, " messageLength ;
    "syscall" ;
] >> ;

[ print ]
[
    #orderFrontEnqueue message ->
    #orderFrontEnqueue length -> 

    [ register ]
    [ [ #orderEnqueue ! length ] getRegisterA ] >> ;

    "sub rsp, " length ;
    "mov " register ", " message ;
    "mov [rsp], " register ;

    [ "rsp" length ] rawPrint ;

    "add rsp, " length ;
] >> ;

[ println ]
[
    print ;

    [ "0xa" "1" ] print ;

] >> ;


/* ------------------ actually coding ------------------ */

int bssInt ;

int dataInt = "69" ;

[ ".rodata" ] #setAssemblySection
[ "db 'moin', 0xa" ] varFromDefineCode wordToGuess ;
[ "equ $ - wordToGuess" ] varFromDefineCode wordLength ;

/* functions */

void Print ( int char )
{
    [ char ! int.size ] println ;

    return ;
}

void Hello ( int p1 , bool p2 , int p3 )
{
    int a = p3 ;
    [ a ! int.size ] println ;

    return ;
}

void Hello2 ( int p1 , int p2 )
{
    int a = p1 ;
    int b = p2 ;

    [ a ! int.size ] println ;
    [ b ! int.size ] println ;

    return ;
}

/* start */
start
{
    [ wordToGuess wordLength ] rawPrint ;

    [ printWord ]
    [ [ wordToGuess wordLength ] rawPrint ] >> ;

    printWord ;

    int num = "65" ; 
    int num2 = "66" ;

    Print ( num ) ;

    "mov eax, " [ num2 ] varSize #executeOrderTop ;
    "add eax, 67" ;

    [ num2 ] = "eax" ;

    Print ( num2 ) ;
    
    [ dataInt ! int.size ] rawPrint ;

    Hello ( num2 , "1" , "69" ) ;

    Hello2 ( num , num2 ) ;

    exit ;
}



