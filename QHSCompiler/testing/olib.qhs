#enterOrderQueue
"aliases.qhs"
#exitOrderQueue
#include
ateArg>>
#exitOrderQueue
#enterOrderQueue

#enterOrderQueue
#orderEnqueue
#orderEnqueue
#orderEnqueue
#force
#deepFetch
#exitOrderQueue
#assign
>
#enterOrderQueue
lateArg>>
#exitOrderQueue
#makeOrderQueueProof
*
------------------
data
handling
------------------
*/

#enterOrderQueue
int.size
#exitOrderQueue
#enterOrderQueue
"4"
#exitOrderQueue
#assign
#enterOrderQueue
int
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#force
int.size
#exitOrderQueue
definition
#exitOrderQueue
#assign
#enterOrderQueue
bool.size
#exitOrderQueue
#enterOrderQueue
"1"
#exitOrderQueue
#assign
#enterOrderQueue
bool
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#force
bool.size
#exitOrderQueue
definition
#exitOrderQueue
#assign
oid
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
"0"
#exitOrderQueue
definition
#exitOrderQueue
#assign
*
assembly
stuff
*/
#enterOrderQueue
getSizeSpecifier
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
pushEnv
byte"
#exitOrderQueue
#assign
#enterOrderQueue
2
"word"
#exitOrderQueue
#assign
#enterOrderQueue
4
"dword"
#exitOrderQueue
#assign
#enterOrderQueue
8
"qword"
#exitOrderQueue
#assign
orderEnqueue
#force
size
#exitOrderQueue
#literalToIdentifier
popEnv
>
etRegisterA
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
pushEnv
al"
#exitOrderQueue
#assign
#enterOrderQueue
2
"ax"
#exitOrderQueue
#assign
#enterOrderQueue
4
"eax"
#exitOrderQueue
#assign
#enterOrderQueue
8
"rax"
#exitOrderQueue
#assign
orderEnqueue
#force
size
#exitOrderQueue
#literalToIdentifier
popEnv
>
etRegisterB
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
pushEnv
bl"
#exitOrderQueue
#assign
#enterOrderQueue
2
"bx"
#exitOrderQueue
#assign
#enterOrderQueue
4
"ebx"
#exitOrderQueue
#assign
#enterOrderQueue
8
"rbx"
#exitOrderQueue
#assign
orderEnqueue
#force
size
#exitOrderQueue
#literalToIdentifier
popEnv
>
etRegisterD
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
pushEnv
dl"
#exitOrderQueue
#assign
#enterOrderQueue
2
"dx"
#exitOrderQueue
#assign
#enterOrderQueue
4
"edx"
#exitOrderQueue
#assign
#enterOrderQueue
8
"rdx"
#exitOrderQueue
#assign
orderEnqueue
#force
size
#exitOrderQueue
#literalToIdentifier
popEnv
>
etDefineSpecifier
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
pushEnv
db"
#exitOrderQueue
#assign
#enterOrderQueue
2
"dw"
#exitOrderQueue
#assign
#enterOrderQueue
4
"dd"
#exitOrderQueue
#assign
#enterOrderQueue
8
"dq"
#exitOrderQueue
#assign
orderEnqueue
#force
size
#exitOrderQueue
#literalToIdentifier
popEnv
>
*
------------------
definitions
------------------
*/
lobalDefinition
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
#enterOrderQueue
name
#exitOrderQueue
lateArg>>
pushEnv
popEnv
orderEnqueue
#force
size
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
dataVar
#exitOrderQueue
#assign
popEnv
orderEnqueue
#force
size
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
ssVar
#exitOrderQueue
#assign
popEnv
orderFrontEnqueue
".text"
#setAssemblySection
pushEnv
functionDefinitionOrderQueue
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
#assign
nitParameterDefinition
*
define
function
in
function
scope
for
recursion
*/

#enterOrderQueue
#lightForce
_functionDefinitionOrderQueue
#exitOrderQueue
defineFuncIdentifier
orderEnqueue
#force
size
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
funcBody
#exitOrderQueue
#assign
>

#exitOrderQueue
#assign
>
*
variables
/
#enterOrderQueue
varFromDefineCode
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
defineCode
#assignToOne
ame
#exitOrderQueue
lateArg>>
*
assigns
what
is
stored
in
name
to
the
direct
code
of
what
is
stored
in
name
*/
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#orderEnqueue
#force
#orderToLiteralCode
#exitOrderQueue
#assign
ame
":
"
defineCode
"
"
>
oDataVar
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
size
#exitOrderQueue
lateArg>>
#enterOrderQueue
name
#exitOrderQueue
lateArg>>
#enterOrderQueue
value
#exitOrderQueue
lateArg>>
efineSpecifier
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getDefineSpecifier
#exitOrderQueue
>
*
assigns
whast
is
stored
in
name
to
the
direct
code
of
what
is
stored
in
name
*/
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#orderEnqueue
#force
#orderToLiteralCode
#exitOrderQueue
#assign
ame
":
"
defineSpecifier
"
"
value
"
"
#exitOrderQueue
#assign
ataVar
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
".data"
#setAssemblySection
orderFrontEnqueue
size
#assignToOne
#orderFrontEnqueue
name
#assignToOne
#orderFrontEnqueue
value
#assignToOne
efineSpecifier
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getDefineSpecifier
#exitOrderQueue
#assign
*
assigns
whast
is
stored
in
name
to
the
direct
code
of
what
is
stored
in
name
*/
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#orderEnqueue
#force
#orderToLiteralCode
#exitOrderQueue
#assign
ame
":
"
defineSpecifier
"
"
value
"
"
#exitOrderQueue
#assign
ssVar
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
".bss"
#setAssemblySection
orderFrontEnqueue
size
#assignToOne
#orderFrontEnqueue
name
#assignToOne
*
assigns
what
is
stored
in
name
to
the
direct
code
of
what
is
stored
in
name
*/
#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
#enterOrderQueue
#orderEnqueue
#force
name
#orderEnqueue
#force
#orderToLiteralCode
#exitOrderQueue
#assign
ame
":
resb
"
size
"
"
>
ocalVar
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
#enterOrderQueue
name
#exitOrderQueue
lateArg>>
izeSpecifier
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getSizeSpecifier
#exitOrderQueue
#assign
rbpOffset"
#orderEnqueue
#force
size
#exitOrderQueue
#changeIntVar
#enterOrderQueue
"rbpOffset"
currentRBPoffset
#orderEnqueue
#force
#getIntVar
#exitOrderQueue
#assign
*
#force
name
=
sizeSpecifier
[rbp-offset]
*/
#enterOrderQueue
#lightForce
size
#exitOrderQueue
#enterOrderQueue
#lightForce
name
#exitOrderQueue
#enterOrderQueue
#lightForce
sizeSpecifier
"
[rbp-"
#lightForce
currentRBPoffset
"]"
#exitOrderQueue
efineVarIdentifier
sub
rsp,
"
size
"
"
pushEnv
popEnv
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
popEnv
egisterA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
"mov
"
name
",
"
registerA
"
"
#exitOrderQueue
#assign
>
popEnv
"
"
#exitOrderQueue
#assign
>
ssign
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
#orderFrontEnqueue
location
#assignToOne
#orderFrontEnqueue
value
#assign
egister
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
mov
"
register
",
"
value
"
"
"mov
"
location
",
"
register
"
"
#exitOrderQueue
#assign
*
return
on
OrderQueue
*/
#enterOrderQueue
varSize
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
variabel
#assignToOne
#force
variabel
#lightForce
#orderToLiteralCode
".size"
#lightForce
#literalCombine
#lightForce
#literalToIdentifier
#exitOrderQueue
#enterOrderQueue
#lightForce
#executeOrderTop
#exitOrderQueue
#exitOrderQueue
#assign
*
expects
Queue
top
as
size,
rest
the
identifier
Assign
for
the
identifier
*/
#enterOrderQueue
defineVarIdentifier
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
#orderFrontEnqueue
identifier
#assignToOne
#orderFrontEnqueue
location
#assign
#force
identifier
#lightForce
location
#exitOrderQueue
#assign
*
IDENTIFIER.size
=
size
*/
#enterOrderQueue
#lightForce
identifier
#lightForce
#orderToLiteralCode
".size"
#lightForce
#literalCombine
#lightForce
#literalToIdentifier
#exitOrderQueue
#enterOrderQueue
#lightForce
size
#exitOrderQueue
#assign
#exitOrderQueue
#assign
*
defintion
current
is
globalDefinition
*/
#enterOrderQueue
definition
globalDefinition
#exitOrderQueue
#assign
*
functions
*/
#enterOrderQueue
resetRBPoffset
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
"rbpOffset"
"0"
#exitOrderQueue
#setIntVar
#exitOrderQueue
#assign
tart
#exitOrderQueue
#enterOrderQueue
#pushEnv
#enterOrderQueue
definition
localVar
#exitOrderQueue
#assign
#enterOrderQueue
{
#exitOrderQueue
#assign

#enterOrderQueue
}
#popEnv
#exitOrderQueue
#assign

.text"
#exitOrderQueue
#setAssemblySection
esetRBPoffset
"
"
"global
_start"
"
"
"_start:"
"
"
"mov
rbp,
rsp"
"
"
#exitOrderQueue
#assign
efineFuncIdentifier
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
name
#assignToOne
#orderFrontEnqueue
parameterSizes
#assign
paramSize"
#lightForce
#getIntVar
#exitOrderQueue
#orderFrontEnqueue
paramSize
#assign
clearOrderQueue

*
funcLabel
=
name
as
literalCode
*/
#enterOrderQueue
#orderEnqueue
#force
name
#orderEnqueue
#force
#orderToLiteralCode
#exitOrderQueue
#orderFrontEnqueue
funcLabel
#assign

#enterOrderQueue
#orderEnqueue
#force
name
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
funcLabel
#orderEnqueue
#force
paramSize
#orderEnqueue
#force
parameterSizes
#exitOrderQueue
uncCall
#exitOrderQueue
#assign
#exitOrderQueue
#assign
#enterOrderQueue
funcBody
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
#orderFrontEnqueue
name
#assignToOne
#enterOrderQueue
return
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
returnBlueprint
#exitOrderQueue
#assign
orderEnqueue
#force
name
#orderEnqueue
#force
#orderToLiteralCode
#exitOrderQueue
#orderFrontEnqueue
funcLabel
#assign
#enterOrderQueue
definition
localVar
#exitOrderQueue
#assign
#enterOrderQueue
{
#exitOrderQueue
#assign

#enterOrderQueue
}
funcBodyEnd
#exitOrderQueue
#assign

.text"
#exitOrderQueue
#setAssemblySection
resetRBPoffset
uncLabel
":"
"
"
"mov
rbp,
rsp"
"
"
#exitOrderQueue
#assign
uncBodyEnd
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#lightForce
_functionDefinitionOrderQueue
#exitOrderQueue
popEnv
efineFuncIdentifier
#exitOrderQueue
#assign
nitParameterDefinition
#exitOrderQueue
#enterOrderQueue

#enterOrderQueue
definition
parameterDefinition
#exitOrderQueue
#assign
*
rbpOffset
=
16
*/
#enterOrderQueue
"rbpOffset"
"16
"]
#setIntVar
*
paramSize
=
0
*/
#enterOrderQueue
"paramSize"
"0"
#exitOrderQueue
#setIntVar
#exitOrderQueue
#assign
arameterDefinition
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
#enterOrderQueue
name
#exitOrderQueue
lateArg>>
izeSpecifier
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getSizeSpecifier
#exitOrderQueue
#assign
*
first
get
RBPoffset
then
rbpOffset
+=
size
*/
#enterOrderQueue
"rbpOffset"
currentRBPoffset
#orderEnqueue
#force
#getIntVar
#exitOrderQueue
#assign
#enterOrderQueue
"rbpOffset"
#orderEnqueue
#force
size
#exitOrderQueue
#changeIntVar

#enterOrderQueue
"paramSize"
#orderEnqueue
#force
size
#exitOrderQueue
#changeIntVar

#enterOrderQueue
newRBPvar
#exitOrderQueue
#enterOrderQueue
"rbp+"
#orderEnqueue
#force
currentRBPoffset
#exitOrderQueue
#assign
#enterOrderQueue
address
#exitOrderQueue
#enterOrderQueue
"["
#orderEnqueue
#force
newRBPvar
"]"
#exitOrderQueue
#assign
sub
rsp,
"
size
"
"
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
name
#exitOrderQueue
#enterOrderQueue
#lightForce
sizeSpecifier
"
[rbp+"
#lightForce
currentRBPoffset
"]"
#exitOrderQueue
defineVarIdentifier
*
_functionDefinitionOrderQueue
+=
size
*/
#enterOrderQueue
_functionDefinitionOrderQueue
#orderEnqueue
#force
_functionDefinitionOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
#assign
#exitOrderQueue
#assign
*
call
with
with
arguments
*/
#enterOrderQueue
funcCall
#exitOrderQueue
#enterOrderQueue
#pushEnv
orderFrontEnqueue
funcLabel
#assignToOne

#orderFrontEnqueue
argSize
#assignToOne
orderFrontEnqueue
argSizes
#assign
)
#exitOrderQueue
#enterOrderQueue
#popEnv
#enterOrderQueue
#orderEnqueue
#force
funcLabel
#exitOrderQueue
literalCall
#exitOrderQueue
#assign
popEnv
#enterOrderQueue
#orderEnqueue
#force
funcLabel
#orderEnqueue
#force
argSize
#exitOrderQueue
literalCall
#exitOrderQueue
#assign
#force
argSize
#exitOrderQueue
initArguments
*
size
=
first
order
stored
in
argSizes
*/
#enterOrderQueue
size
#exitOrderQueue
#enterOrderQueue
#lightForce
argSizes
#exitOrderQueue
#assignToOne
#orderFrontEnqueue
argSizes
#assign
*
argument
need
to
be
last
instruction
as
otherwise
the
expr
call
in
argument
would
get
something
from
this
*/
#enterOrderQueue
#lightForce
size
#exitOrderQueue
argument
#exitOrderQueue
#assign
ize
#exitOrderQueue
#enterOrderQueue
#lightForce
argSizes
#exitOrderQueue
#assignToOne
#orderFrontEnqueue
argSizes
#assign
*
argument
need
to
be
last
instruction
as
otherwise
the
expr
call
in
argument
would
get
something
from
this
*/
#enterOrderQueue
#lightForce
size
#exitOrderQueue
argument
#exitOrderQueue
#assign
#exitOrderQueue
#assign
*
just
the
call
assembly
code
*/
#enterOrderQueue
literalCall
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
funcLabel
#assignToOne
orderFrontEnqueue
argSize
#assignToOne
push
rbp"
"
"
"call
"
funcLabel
"
"
"pop
rbp"
"
"
"add
rsp,
"
argSize
"
"
#exitOrderQueue
#assign
nitArguments
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
argSize
#assignToOne
rbpOffset"
currentRBPoffset
#orderEnqueue
#force
#getIntVar
#exitOrderQueue
#assign
#enterOrderQueue
"argOffset"
#orderEnqueue
#force
currentRBPoffset
#exitOrderQueue
#setIntVar
#enterOrderQueue
"argOffset"
#orderEnqueue
#force
argSize
#exitOrderQueue
#changeIntVar
sub
rsp,
"
argSize
"
"
#exitOrderQueue
#assign
rgument
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
#enterOrderQueue
value
#lightForce
#deepFetch
#exitOrderQueue
#assign
#enterOrderQueue
sizeSpecifier
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getSizeSpecifier
#exitOrderQueue
#assign
*
currentArgoffset
=
argOffset
var
*/
#enterOrderQueue
"argOffset"
currentArgOffset
#lightForce
#getIntVar
#exitOrderQueue
#assign

#enterOrderQueue
newLocation
#exitOrderQueue
#enterOrderQueue
#lightForce
sizeSpecifier
"
[rbp-"
#lightForce
currentArgOffset
"]"
#exitOrderQueue
#assign
*
change
arg
offset,
which
was
set
in
initArguments
*/

#enterOrderQueue
"-"
#lightForce
size
#lightForce
#literalCombine
#exitOrderQueue
orderFrontEnqueue
"argOffset"
#changeIntVar
#force
size
#exitOrderQueue
#enterOrderQueue
newLocation
#exitOrderQueue
#enterOrderQueue
#lightForce
value
#exitOrderQueue
assign
#exitOrderQueue
#assign
*
return
but
it
needs
a
argument,
return
is
defined
as
#enterOrderQueue
"size"
#exitOrderQueue
returnBlueprint
*/
#enterOrderQueue
returnBlueprint
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
pushEnv
popEnv
*
clear
rax
as
expr
will
write
partially
over
it.
eg
al
*/
"xor
rax,
rax"
"
"
#enterOrderQueue
#lightForce
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
*
redefinition
as
oly
one
was
lost
by
#popEnv
*/
#enterOrderQueue
"
" #clearOrderQueue
#exitOrderQueue
#enterOrderQueue
#popEnv
mov
rsp,
rbp"
"
"
"ret"
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
popEnv
mov
rsp,
rbp"
"
"
"ret"
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
*
------------------
expressions
------------------
*/
xprInit
#exitOrderQueue
#enterOrderQueue
#pushEnv
#orderFrontEnqueue
size
#assignToOne
#orderFrontEnqueue
first
#assign
izeSpecifier
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getSizeSpecifier
#exitOrderQueue
#assign
egisterA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
egisterB
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterB
#exitOrderQueue
#assign
egisterD
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterD
#exitOrderQueue
#assign
mov
"
registerA
",
"
first
"
"
add
"
registerA
",
"
#deepFetch
"
"
#exitOrderQueue
#assign
sub
"
registerA
",
"
#deepFetch
"
"
#exitOrderQueue
#assign
mov
"
registerD
",
"
#deepFetch
"
"
"mul
"
registerD
"
"
#exitOrderQueue
#assign
mov
"
registerB
",
"
#deepFetch
"
"
"xor
rdx,
rdx"
"
"
"div
"
registerB
"
"
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
"cmp
"
registerA
",
"
#deepFetch
"
"
"sete
dl"
"
"
"xor
rax,
rax"
"
"
"mov
al,
dl"
"
"
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
"cmp
"
registerA
",
"
#deepFetch
"
"
"setne
dl"
"
"
"xor
rax,
rax"
"
"
"mov
al,
dl"
"
"
#exitOrderQueue
#assign
cmp
"
registerA
",
"
#deepFetch
"
"
"setl
dl"
"
"
"xor
rax,
rax"
"
"
"mov
al,
dl"
"
"
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
"cmp
"
registerA
",
"
#deepFetch
"
"
"setle
dl"
"
"
"xor
rax,
rax"
"
"
"mov
al,
dl"
"
"
#exitOrderQueue
#assign
cmp
"
registerA
",
"
#deepFetch
"
"
"setg
dl"
"
"
"xor
rax,
rax"
"
"
"mov
al,
dl"
"
"
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
"cmp
"
registerA
",
"
#deepFetch
"
"
"setge
dl"
"
"
"xor
rax,
rax"
"
"
"mov
al,
dl"
"
"
#exitOrderQueue
#assign
&
#exitOrderQueue
#enterOrderQueue
"and
"
registerA
",
"
#deepFetch
"
"
#exitOrderQueue
#assign
|
#exitOrderQueue
#enterOrderQueue
"or
"
registerA
",
"
#deepFetch
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
orderFrontEnqueue
var
#assignToOne

#enterOrderQueue
#lightForce
var
#exitOrderQueue
varSize
#orderFrontEnqueue
size
#assign
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
popEnv
#enterOrderQueue
registerA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
"mov
"
var
",
"
registerA
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
var
#assignToOne

#enterOrderQueue
#lightForce
var
#exitOrderQueue
varSize
#orderFrontEnqueue
size
#assign
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
popEnv
#enterOrderQueue
registerA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
add
"
var
",
"
registerA
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
var
#assignToOne

#enterOrderQueue
#lightForce
var
#exitOrderQueue
varSize
#orderFrontEnqueue
size
#assign
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
popEnv
#enterOrderQueue
registerA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
sub
"
var
",
"
registerA
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
var
#assignToOne

#enterOrderQueue
#lightForce
var
#exitOrderQueue
varSize
#orderFrontEnqueue
size
#assign
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
popEnv
#enterOrderQueue
registerA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
#enterOrderQueue
registerD
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterD
#exitOrderQueue
#assign
mov
"
registerD
",
"
registerA
"
"
"mov
"
registerA
",
"
var
"
"
"mul
"
registerD
"
"
"mov
"
var
",
"
registerA
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
=
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
var
#assignToOne

#enterOrderQueue
#lightForce
var
#exitOrderQueue
varSize
#orderFrontEnqueue
size
#assign
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
popEnv
#enterOrderQueue
registerA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
#enterOrderQueue
registerB
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterB
#exitOrderQueue
#assign
mov
"
registerB
",
"
registerA
"
"
"xor
rdx,
rdx"
"
"
"mov
"
registerA
",
"
var
"
"
"div
"
registerB
"
"
"mov
"
var
",
"
registerA
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
*
------------------
constrol
flow
------------------
*/
currentJumpLabel"
"0"
#exitOrderQueue
#setIntVar
*
returns
to
order
queue
*/
#enterOrderQueue
newJumpLabel
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
"currentJumpLabel"
"1"
#exitOrderQueue
#changeIntVar
#enterOrderQueue
"currentJumpLabel"
"JL"
#lightForce
#getIntVar
#lightForce
#literalCombine
#exitOrderQueue
#exitOrderQueue
#assign
hile
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
ewJumpLabel
#orderFrontEnqueue
startLabel
#assign

newJumpLabel
#orderFrontEnqueue
endLabel
#assign

egisterA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
tartLabel
":"
"
"
pushEnv
orderEnqueue
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
#exitOrderQueue
#assign
popEnv
"test
"
registerA
",
"
registerA
"
"
"jz
"
endLabel
"
"
#exitOrderQueue
#assign
*
{
=
none
*/
#exitOrderQueue
#assign
popEnv

"jmp
"
startLabel
"
"
endLabel
":"
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
f
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
ewJumpLabel
#orderFrontEnqueue
endLabel
#assign

egisterA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
pushEnv
orderEnqueue
#force
size
#exitOrderQueue
#enterOrderQueue
#lightForce
#deepFetch
#exitOrderQueue
exprInit
#exitOrderQueue
#assign
popEnv
"test
"
registerA
",
"
registerA
"
"
"jz
"
endLabel
"
"
#exitOrderQueue
#assign
*
{
=
none
*/
#exitOrderQueue
#assign
popEnv

endLabel
":"
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
lse
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
size
#assignToOne
ewJumpLabel
#orderFrontEnqueue
endLabel
#assign

egisterA
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
size
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
pushEnv
*
expression
result
is
still
stored
in
registerA
*/

"test
"
registerA
",
"
registerA
"
"
"jnz
"
endLabel
"
"
*
{
=
none
*/
#exitOrderQueue
#assign
popEnv

endLabel
":"
"
"
#exitOrderQueue
#assign
#exitOrderQueue
#assign
*
------------------
syscalls
------------------
*/
#enterOrderQueue
exit
#exitOrderQueue
#enterOrderQueue
"mov
rax,
60"
"
"
"mov
rdi,
0"
"
"
"syscall"
"
"
#exitOrderQueue
#assign
awPrint
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
message
#assignToOne
#orderFrontEnqueue
messageLength
#assignToOne
"mov
rax,
1"
"
"
"mov
rdi,
1"
"
"
"mov
rsi,
"
message
"
"
"mov
rdx,
"
messageLength
"
"
"syscall"
"
"
#exitOrderQueue
#assign
rint
#exitOrderQueue
#enterOrderQueue
#orderFrontEnqueue
message
#assignToOne
#orderFrontEnqueue
length
#assignToOne
#enterOrderQueue
register
#exitOrderQueue
#enterOrderQueue
#enterOrderQueue
#orderEnqueue
#force
length
#exitOrderQueue
getRegisterA
#exitOrderQueue
#assign
sub
rsp,
"
length
"
"
"mov
"
register
",
"
message
"
"
"mov
[rsp],
"
register
"
"
rsp"
length
#exitOrderQueue
rawPrint
"
"
add
rsp,
"
length
"
"
#exitOrderQueue
#assign
rintln
#exitOrderQueue
#enterOrderQueue
print
"
"
0xa"
"1"
#exitOrderQueue
print
"
"
>
